#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
genai.py - GenAI-based linking implementation for Auto Link Obsidian

This module implements linking between notes with explanations generated by AI.
"""

import os
import time
import random
from typing import Dict, List, Set, Optional, Any, Tuple
from tqdm import tqdm

from ..core.note import Note
from ..core.config import config
from ..utils.markdown import extract_links
from .base_linker import BaseLinker, linker_registry


class GenAILinker(BaseLinker):
    """
    Linker implementation that connects notes with AI-generated explanations.
    """
    
    TYPE = "genai"
    SECTION_HEADER = "## Related Notes (GenAI)"
    
    def __init__(self, vault_path: Optional[str] = None):
        """
        Initialize the GenAI linker.
        
        Args:
            vault_path: Path to the Obsidian vault
        """
        super().__init__(vault_path)
        
        # Get configuration
        self.model = config.get("genai_model", "gpt-3.5-turbo")
        self.notes_per_run = config.get("genai_notes", 100)
        
        # Initialize OpenAI client
        try:
            from openai import OpenAI
            self.client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY"))
        except ImportError:
            raise ImportError("OpenAI package not installed. Install it with 'pip install openai'.")
        except Exception as e:
            raise ValueError(f"Error initializing OpenAI client: {str(e)}")
        
        # Print configuration info
        print(f"Initialized GenAI linker with model {self.model}, processing {self.notes_per_run} notes per run")
    
    def process_notes(self) -> int:
        """
        Process notes to generate links with AI-generated explanations.
        
        Returns:
            Number of notes processed
        """
        # Filter notes to determine which ones need processing
        notes_to_process = self.filter_notes_to_process()
        
        if not notes_to_process:
            print("No notes to process")
            return 0
            
        # Select notes for this run (limited by notes_per_run)
        selected_notes = self._select_notes_for_processing(notes_to_process)
        print(f"Processing {len(selected_notes)} notes out of {len(self.notes)} total")
        
        # Extract summaries for all notes
        print("Extracting note summaries...")
        summaries = self._extract_summaries()
        
        # Process selected notes
        processed_count = 0
        for path in tqdm(selected_notes, desc="Finding AI-powered links"):
            try:
                # Get the note
                note = self.notes[path]
                
                # Find relevant notes using AI
                relevant_notes = self._find_relevant_notes(path, summaries)
                
                if not relevant_notes:
                    continue
                
                # Get existing links
                current_links = extract_links(note.content)
                
                # Format link entries
                link_entries = []
                for rel_note in relevant_notes:
                    rel_path = rel_note["path"]
                    rel_note_obj = self.notes[rel_path]
                    
                    # Skip if already linked
                    if rel_note_obj.title in current_links:
                        continue
                    
                    # Format the link with relevance score and reason
                    link_entry = f"- [[{rel_note_obj.title}]] (Score: {rel_note['score']}/10)\n  - {rel_note['reason']}"
                    link_entries.append(link_entry)
                
                # Only update if we have links to add
                if link_entries:
                    # Add links to the note
                    note.add_links(link_entries, self.SECTION_HEADER)
                    processed_count += 1
                    
            except Exception as e:
                print(f"Error processing note {path}: {str(e)}")
        
        print(f"Added GenAI links to {processed_count} notes")
        return processed_count
    
    def _select_notes_for_processing(self, notes_to_process: Dict[str, Note]) -> List[str]:
        """
        Select a subset of notes for processing in this run.
        
        Args:
            notes_to_process: Dictionary of notes that need processing
            
        Returns:
            List of note paths selected for processing
        """
        # If we have fewer notes than the limit, process all of them
        if len(notes_to_process) <= self.notes_per_run:
            return list(notes_to_process.keys())
        
        # Select notes to process
        selected = random.sample(list(notes_to_process.keys()), self.notes_per_run)
        return selected
    
    def _extract_summaries(self) -> Dict[str, Dict[str, Any]]:
        """
        Extract title and summary for all notes.
        
        Returns:
            Dictionary mapping note paths to summary dictionaries
        """
        summaries = {}
        
        for path, note in self.notes.items():
            title = note.title
            summary = note.get_summary()
            
            summaries[path] = {
                "title": title,
                "summary": summary
            }
        
        return summaries
    
    def _find_relevant_notes(self, target_path: str, summaries: Dict[str, Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Find relevant notes for a target note using AI.
        
        Args:
            target_path: Path to the target note
            summaries: Dictionary mapping note paths to summary dictionaries
            
        Returns:
            List of dictionaries with relevant note information
        """
        target_summary = summaries[target_path]
        target_note = self.notes[target_path]
        
        # Get a random sample of other notes
        other_paths = [p for p in summaries.keys() if p != target_path]
        
        # Limit to 50 random notes for comparison to avoid token limits
        if len(other_paths) > 50:
            other_paths = random.sample(other_paths, 50)
        
        # Prepare candidate notes
        candidates = []
        for path in other_paths:
            summary = summaries[path]
            candidates.append({
                "path": path,
                "title": summary["title"],
                "summary": summary["summary"]
            })
        
        # No candidates to compare with
        if not candidates:
            return []
        
        # Prepare the prompt for the AI
        prompt = f"""
        Target Note: "{target_summary['title']}"
        Target Summary: "{target_summary['summary']}"
        
        Candidate Notes:
        {self._format_candidates(candidates)}
        
        Task: For each candidate note, determine if it's related to the target note.
        Find 3-5 of the most relevant candidate notes and explain the connection.
        
        For each relevant note, provide:
        1. The note index
        2. A relevance score (1-10)
        3. A one-sentence explanation of why they're related
        
        Format: Use the exact format below for each relevant note:
        #INDEX|SCORE|REASON
        
        Example:
        #2|8|Both discuss the implementation of neural networks in PyTorch.
        #7|6|The target note references concepts explained in this candidate.
        """
        
        try:
            # Call the OpenAI API
            response = self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": "You are a helpful assistant that identifies connections between notes."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.5,
                max_tokens=1000
            )
            
            # Parse the response
            content = response.choices[0].message.content.strip()
            
            # Extract the relevant notes
            relevant_notes = []
            for line in content.split('\n'):
                line = line.strip()
                
                # Skip empty lines
                if not line:
                    continue
                    
                # Try to parse the line
                if line.startswith('#'):
                    try:
                        # Remove the # and split by |
                        parts = line[1:].split('|')
                        
                        if len(parts) == 3:
                            idx, score, reason = parts
                            
                            # Convert index to integer
                            idx = int(idx.strip())
                            
                            # Convert score to integer
                            score = int(float(score.strip()))
                            
                            # Get the candidate note
                            if 0 <= idx < len(candidates):
                                candidate = candidates[idx]
                                
                                # Add to relevant notes
                                relevant_notes.append({
                                    "path": candidate["path"],
                                    "score": score,
                                    "reason": reason.strip()
                                })
                    except Exception as e:
                        print(f"Error parsing line '{line}': {str(e)}")
            
            # Sort by score (descending)
            relevant_notes.sort(key=lambda x: x["score"], reverse=True)
            
            return relevant_notes
            
        except Exception as e:
            print(f"Error calling OpenAI API: {str(e)}")
            return []
    
    def _format_candidates(self, candidates: List[Dict[str, Any]]) -> str:
        """
        Format candidate notes for the prompt.
        
        Args:
            candidates: List of candidate note dictionaries
            
        Returns:
            Formatted string for the prompt
        """
        formatted = []
        
        for i, candidate in enumerate(candidates):
            formatted.append(f"#{i}: {candidate['title']}\nSummary: {candidate['summary']}\n")
        
        return "\n".join(formatted)


# Register the linker
linker_registry["genai"] = GenAILinker